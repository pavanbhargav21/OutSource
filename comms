

from datetime import datetime, date, timedelta
from dateutil.relativedelta import relativedelta
from typing import Optional
from fastapi import Query, Header, Depends
from fastapi.responses import JSONResponse
from fastapi import status
from auth.jwt_handler import AuthJWT

@router.get('/get_team_active_idle_app_category')
async def get_team_app_activity(
    Authorize: AuthJWT = Depends(),
    authorization: str = Header(None),
    start_date: str = Query(...),
    end_date: str = Query(...),
    date_range: Optional[str] = Query("day")
):
    if not authorization or not authorization.startswith("Bearer"):
        return JSONResponse(
            status_code=status.HTTP_400_BAD_REQUEST,
            content={"msg": "Authorization Token Missing"}
        )
    
    try:
        Authorize.jwt_required()
        user_identity = Authorize.get_jwt_subject()
        claims = Authorize.get_raw_jwt()
        manager_id = claims.get("user_id")
        
        if not manager_id:
            return JSONResponse(
                status_code=status.HTTP_401_UNAUTHORIZED,
                content={'message': "Invalid Token Claims"}
            )
        
        today = datetime.today().date()
        
        if start_date and end_date:
            try:
                start_date_dt = datetime.strptime(start_date, "%Y-%m-%d").date()
                end_date_dt = datetime.strptime(end_date, "%Y-%m-%d").date()
                
                period_days = (end_date_dt - start_date_dt).days + 1
                
                # Handle different date range types
                if date_range.lower() == "day":
                    # Previous week's same day
                    prev_start_date = start_date_dt - timedelta(days=7)
                    prev_end_date = prev_start_date  # Same day for day range
                    ext_end_date = end_date_dt + timedelta(days=1)
                    
                elif date_range.lower() == "week":
                    # Previous week's same days (exact number of days)
                    prev_start_date = start_date_dt - timedelta(days=7)
                    prev_end_date = end_date_dt - timedelta(days=7)
                    ext_end_date = end_date_dt + timedelta(days=1)
                    
                elif date_range.lower() == "month":
                    # Check if selected dates are in current month
                    current_month = today.month
                    current_year = today.year
                    selected_month = start_date_dt.month
                    selected_year = start_date_dt.year
                    
                    if selected_month == current_month and selected_year == current_year:
                        # Current month: go back exactly 4 weeks (28 days)
                        prev_start_date = start_date_dt - timedelta(days=28)
                        prev_end_date = end_date_dt - timedelta(days=28)
                    else:
                        # Not current month: previous month's start and end
                        # Get first day of previous month for start_date
                        prev_start_date = (start_date_dt.replace(day=1) - relativedelta(months=1)).replace(day=1)
                        
                        # Get last day of previous month for end_date
                        prev_month_end = (end_date_dt.replace(day=1) - relativedelta(months=1))
                        prev_end_date = (prev_month_end + relativedelta(months=1, days=-1))
                    
                    ext_end_date = end_date_dt + timedelta(days=1)
                
                else:
                    # Default to day logic for unknown ranges
                    prev_start_date = start_date_dt - timedelta(days=7)
                    prev_end_date = prev_start_date
                    ext_end_date = end_date_dt + timedelta(days=1)
                
                # Return the calculated dates
                return {
                    "start_date": start_date_dt.isoformat(),
                    "end_date": end_date_dt.isoformat(),
                    "previous_start_date": prev_start_date.isoformat(),
                    "previous_end_date": prev_end_date.isoformat(),
                    "extended_end_date": ext_end_date.isoformat(),
                    "date_range": date_range,
                    "period_days": period_days
                }
                
            except ValueError:
                return JSONResponse(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    content={"msg": "Invalid date format. Use YYYY-MM-DD."}
                )
        else:
            # Default to daily when no dates provided
            start_date_dt = today
            end_date_dt = today
            prev_start_date = today - timedelta(days=7)
            prev_end_date = prev_start_date
            ext_end_date = today + timedelta(days=1)
            
            return {
                "start_date": start_date_dt.isoformat(),
                "end_date": end_date_dt.isoformat(),
                "previous_start_date": prev_start_date.isoformat(),
                "previous_end_date": prev_end_date.isoformat(),
                "extended_end_date": ext_end_date.isoformat(),
                "date_range": "day",
                "period_days": 1
            }
            
    except Exception as e:
        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content={"msg": f"Internal server error: {str(e)}"}
        )







Here’s a cleaner, structured draft you can use for your proposal email or document:


---

Subject: Proposal to Exclude Week-Off Data from Average Calculations in RPEM APIs

Background:
Currently, our system captures and stores agent activity data for all employees, regardless of whether the date falls on a working day or a week-off (e.g., Saturday, Sunday, or designated weekly off-days). This includes cases where an employee might log in briefly (e.g., 10 minutes or 1 hour) during their week-off.

When average calculations are performed — whether for a week, month, or custom date range — this week-off data is included in the calculation. As a result:

A small amount of activity on a week-off skews both individual and team averages.

The reported averages may not accurately reflect true working-day performance.


Proposed Change:
For all APIs that calculate averages in RPEM, we propose excluding week-off employee activity from the average computation. This means:

If a date is a week-off for a given employee, their data for that date will be ignored in average calculations.

Averages will be calculated only on valid working days for each employee.


Expected Benefits:

More accurate and meaningful average metrics for individuals and teams.

Avoids distortion of averages caused by minimal week-off activity.

Consistency across all APIs, regardless of the selected time period filter (week, month, or custom).


Scope:

Changes will be implemented in all RPEM APIs that involve average calculations.

The logic to exclude week-off data will be applied at the calculation stage.


Request:
We seek sign-off on this proposal so that development can proceed with updating all relevant APIs to exclude week-off data from average computations.


---

Do you want me to also add a visual example showing how averages change before vs. after this change? That would make the proposal even easier to approve.

