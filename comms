
WITH ActivityWithShiftBounds AS (
  SELECT
    i.emp_id,
    i.shift_date,
    i.start_time,
    i.end_time,
    i.interval_start,
    i.interval_end,
    i.emp_login_time,
    i.emp_logout_time,
    i.total_time_active,
    i.total_time_idle,
    i.window_lock_time,
    greatest(i.interval_start, i.start_time) AS overlap_start,
    least(i.interval_end, i.end_time) AS overlap_end,
    greatest(i.interval_start, i.emp_login_time) AS activity_start,
    least(i.interval_end, i.emp_logout_time) AS activity_end
  FROM FilteredAppInfo i
  LEFT JOIN EmployeeShiftsWithConfig s
    ON i.emp_id = s.emp_id AND i.shift_date = s.shift_date
),

ActivityTimeAllocation AS (
  SELECT
    emp_id,
    shift_date,
    total_time_active,
    total_time_idle,
    window_lock_time,
    start_time,
    end_time,
    activity_start,
    activity_end,
    
    -- Calculate seconds within shift (considers BOTH login/logout AND shift boundaries)
    CASE 
      WHEN activity_start >= end_time OR activity_end <= start_time THEN
        0
      WHEN activity_start >= start_time AND activity_end <= end_time THEN
        unix_timestamp(activity_end) - unix_timestamp(activity_start)
      ELSE
        unix_timestamp(least(activity_end, end_time)) - unix_timestamp(greatest(activity_start, start_time))
    END AS seconds_within_shift,
    
    -- Calculate seconds outside shift
    CASE 
      WHEN activity_start >= end_time OR activity_end <= start_time THEN
        unix_timestamp(activity_end) - unix_timestamp(activity_start)
      WHEN activity_start >= start_time AND activity_end <= end_time THEN
        0
      ELSE
        (unix_timestamp(activity_end) - unix_timestamp(activity_start)) - 
        (unix_timestamp(least(activity_end, end_time)) - unix_timestamp(greatest(activity_start, start_time)))
    END AS seconds_outside_shift,
    
    -- Total activity seconds for validation
    unix_timestamp(activity_end) - unix_timestamp(activity_start) AS total_activity_seconds
    
  FROM ActivityWithShiftBounds
  WHERE activity_start < activity_end
),

CurrentShiftData AS (
  SELECT
    a.emp_id,
    a.shift_date,
    
    -- Total metrics
    SUM(total_time_active) AS total_active_time,
    SUM(total_time_idle) AS total_idle_time,
    SUM(window_lock_time) AS total_lock_time,
    SUM(total_time_active + total_time_idle + window_lock_time) AS total_work_time,
    
    -- Within shift allocation
    SUM(
      CASE 
        WHEN (seconds_within_shift + seconds_outside_shift) = 0 THEN 0
        ELSE total_time_active * (seconds_within_shift / (seconds_within_shift + seconds_outside_shift))
      END
    ) AS active_within_shift,
    
    SUM(
      CASE 
        WHEN (seconds_within_shift + seconds_outside_shift) = 0 THEN 0
        ELSE total_time_idle * (seconds_within_shift / (seconds_within_shift + seconds_outside_shift))
      END
    ) AS idle_within_shift,
    
    SUM(
      CASE 
        WHEN (seconds_within_shift + seconds_outside_shift) = 0 THEN 0
        ELSE window_lock_time * (seconds_within_shift / (seconds_within_shift + seconds_outside_shift))
      END
    ) AS lock_within_shift,
    
    -- Outside shift allocation (only active + idle, no lock time)
    SUM(
      CASE 
        WHEN (seconds_within_shift + seconds_outside_shift) = 0 THEN 0
        ELSE total_time_active * (seconds_outside_shift / (seconds_within_shift + seconds_outside_shift))
      END
    ) AS active_outside_shift,
    
    SUM(
      CASE 
        WHEN (seconds_within_shift + seconds_outside_shift) = 0 THEN 0
        ELSE total_time_idle * (seconds_outside_shift / (seconds_within_shift + seconds_outside_shift))
      END
    ) AS idle_outside_shift,
    
    -- Shift configuration
    MAX(s.pulse_shift_time) AS pulse_shift_time,
    MAX(s.adjusted_active_time) AS adjusted_active_time,
    MAX(s.adjusted_lock_time) AS adjusted_lock_time,
    MIN(s.start_time) AS shift_start_time,
    MAX(s.end_time) AS shift_end_time,
    
    -- Debug totals for validation
    SUM(seconds_within_shift) AS total_seconds_within_shift,
    SUM(seconds_outside_shift) AS total_seconds_outside_shift,
    SUM(total_activity_seconds) AS total_activity_seconds
    
  FROM ActivityTimeAllocation a
  JOIN EmployeeShiftsWithConfig s
    ON a.emp_id = s.emp_id AND a.shift_date = s.shift_date
  GROUP BY a.emp_id, a.shift_date
)

SELECT
  emp_id,
  shift_date,
  total_active_time,
  total_idle_time,
  total_lock_time,
  total_work_time,
  active_within_shift,
  idle_within_shift,
  lock_within_shift,
  active_outside_shift,
  idle_outside_shift,
  (active_within_shift + idle_within_shift + lock_within_shift) AS time_within_shift,
  (active_outside_shift + idle_outside_shift) AS time_outside_shift,
  pulse_shift_time,
  adjusted_active_time,
  adjusted_lock_time,
  shift_start_time,
  shift_end_time,
  -- Debug columns (can remove in production)
  total_seconds_within_shift,
  total_seconds_outside_shift,
  total_activity_seconds
FROM CurrentShiftData
ORDER BY emp_id, shift_date






Let me walk through your examples using Approach 1 logic:

Example 1: Shift 10:25:00 - 19:25:00, Login 10:45:12, Logout 20:42:45

For 10:00-11:00 interval:

· Activity: 10:45:12 - 11:00:00 (14m48s)
· seconds_within_shift = unix_timestamp('11:00:00') - unix_timestamp('10:45:12') = 888 seconds
· seconds_outside_shift = 0 seconds (all within shift)
· Ratio = 888/(888+0) = 1.0
· Result: 100% of active/idle/lock time allocated to WITHIN shift

For 19:00-20:00 interval:

· Activity: 19:00:00 - 20:00:00 (60m)
· Within shift portion: 19:00:00 - 19:25:00 (25m)
· Outside shift portion: 19:25:00 - 20:00:00 (35m)
· seconds_within_shift = unix_timestamp('19:25:00') - unix_timestamp('19:00:00') = 1500 seconds
· seconds_outside_shift = unix_timestamp('20:00:00') - unix_timestamp('19:25:00') = 2100 seconds
· Ratio = 1500/(1500+2100) = 0.4167 (within), 0.5833 (outside)
· Result: 41.67% of active/idle/lock to WITHIN shift, 58.33% of active/idle to OUTSIDE shift

For 20:00-21:00 interval:

· Activity: 20:00:00 - 20:42:45 (42m45s)
· seconds_within_shift = 0 seconds (completely after shift end)
· seconds_outside_shift = unix_timestamp('20:42:45') - unix_timestamp('20:00:00') = 2565 seconds
· Ratio = 0/(0+2565) = 0.0 (within), 1.0 (outside)
· Result: 100% of active/idle to OUTSIDE shift, 0% lock time

---

Example 2: Shift 10:25:00 - 19:25:00, Login 09:12:14, Logout 16:20:00

For 09:00-10:00 interval:

· Activity: 09:12:14 - 10:00:00 (47m46s)
· seconds_within_shift = 0 seconds (completely before shift start)
· seconds_outside_shift = unix_timestamp('10:00:00') - unix_timestamp('09:12:14') = 2866 seconds
· Ratio = 0/(0+2866) = 0.0 (within), 1.0 (outside)
· Result: 100% of active/idle to OUTSIDE shift

For 10:00-11:00 interval:

· Activity: 10:00:00 - 11:00:00 (60m)
· Within shift portion: 10:25:00 - 11:00:00 (35m)
· Outside shift portion: 10:00:00 - 10:25:00 (25m)
· seconds_within_shift = unix_timestamp('11:00:00') - unix_timestamp('10:25:00') = 2100 seconds
· seconds_outside_shift = unix_timestamp('10:25:00') - unix_timestamp('10:00:00') = 1500 seconds
· Ratio = 2100/(2100+1500) = 0.5833 (within), 0.4167 (outside)
· Result: 58.33% of active/idle/lock to WITHIN shift, 41.67% of active/idle to OUTSIDE shift

---

Example 3: Shift 09:30:00 - 18:30:00, Login 10:15:12, Logout 20:42:45

For 10:00-11:00 interval:

· Activity: 10:15:12 - 11:00:00 (44m48s)
· seconds_within_shift = unix_timestamp('11:00:00') - unix_timestamp('10:15:12') = 2688 seconds
· seconds_outside_shift = 0 seconds (all within shift)
· Ratio = 2688/(2688+0) = 1.0
· Result: 100% of active/idle/lock to WITHIN shift

For 18:00-19:00 interval:

· Activity: 18:00:00 - 19:00:00 (60m)
· Within shift portion: 18:00:00 - 18:30:00 (30m)
· Outside shift portion: 18:30:00 - 19:00:00 (30m)
· seconds_within_shift = unix_timestamp('18:30:00') - unix_timestamp('18:00:00') = 1800 seconds
· seconds_outside_shift = unix_timestamp('19:00:00') - unix_timestamp('18:30:00') = 1800 seconds
· Ratio = 1800/(1800+1800) = 0.5 (within), 0.5 (outside)
· Result: 50% of active/idle/lock to WITHIN shift, 50% of active/idle to OUTSIDE shift

Key Points:

1. Automatic handling: The ratio seconds_within_shift/(total_seconds) automatically gives correct allocation
2. Complete within: Ratio = 1.0 → 100% within shift
3. Complete outside: Ratio = 0.0 → 100% outside shift
4. Partial overlap: Exact proportional split based on time
5. Lock time: Only gets allocated to within-shift portion (as per business rule)

The logic is mathematically precise and handles all your scenarios correctly!






from datetime import datetime, date, timedelta
from typing import Optional
from fastapi import Query, Header, Depends
from fastapi.responses import JSONResponse
from fastapi import status
from auth.jwt_handler import AuthJWT

def get_last_day_of_month(dt: date) -> date:
    """Get the last day of the month for a given date"""
    if dt.month == 12:
        return date(dt.year + 1, 1, 1) - timedelta(days=1)
    return date(dt.year, dt.month + 1, 1) - timedelta(days=1)

@router.get('/get_team_active_idle_app_category')
async def get_team_app_activity(
    Authorize: AuthJWT = Depends(),
    authorization: str = Header(None),
    start_date: str = Query(...),
    end_date: str = Query(...),
    date_range: Optional[str] = Query("day")
):
    if not authorization or not authorization.startswith("Bearer"):
        return JSONResponse(
            status_code=status.HTTP_400_BAD_REQUEST,
            content={"msg": "Authorization Token Missing"}
        )
    
    try:
        Authorize.jwt_required()
        user_identity = Authorize.get_jwt_subject()
        claims = Authorize.get_raw_jwt()
        manager_id = claims.get("user_id")
        
        if not manager_id:
            return JSONResponse(
                status_code=status.HTTP_401_UNAUTHORIZED,
                content={'message': "Invalid Token Claims"}
            )
        
        today = datetime.today().date()
        
        if start_date and end_date:
            try:
                start_date_dt = datetime.strptime(start_date, "%Y-%m-%d").date()
                end_date_dt = datetime.strptime(end_date, "%Y-%m-%d").date()
                
                period_days = (end_date_dt - start_date_dt).days + 1
                
                # Handle different date range types
                if date_range.lower() == "day":
                    # Previous week's same day
                    prev_start_date = start_date_dt - timedelta(days=7)
                    prev_end_date = prev_start_date
                    ext_end_date = end_date_dt + timedelta(days=1)
                    
                elif date_range.lower() == "week":
                    # Previous week's same days
                    prev_start_date = start_date_dt - timedelta(days=7)
                    prev_end_date = end_date_dt - timedelta(days=7)
                    ext_end_date = end_date_dt + timedelta(days=1)
                    
                elif date_range.lower() == "month":
                    # Check if selected dates are in current month
                    current_month = today.month
                    current_year = today.year
                    selected_month = start_date_dt.month
                    selected_year = start_date_dt.year
                    
                    if selected_month == current_month and selected_year == current_year:
                        # Current month: go back exactly 4 weeks (28 days)
                        prev_start_date = start_date_dt - timedelta(days=28)
                        prev_end_date = end_date_dt - timedelta(days=28)
                    else:
                        # Not current month: previous month's start and end
                        if start_date_dt.month == 1:
                            prev_start_date = date(start_date_dt.year - 1, 12, 1)
                        else:
                            prev_start_date = date(start_date_dt.year, start_date_dt.month - 1, 1)
                        
                        if end_date_dt.month == 1:
                            prev_end_date = date(end_date_dt.year - 1, 12, 31)
                        else:
                            prev_month = end_date_dt.month - 1
                            prev_year = end_date_dt.year
                            if prev_month == 0:
                                prev_month = 12
                                prev_year = end_date_dt.year - 1
                            prev_end_date = get_last_day_of_month(date(prev_year, prev_month, 1))
                    
                    ext_end_date = end_date_dt + timedelta(days=1)
                
                else:
                    # DEFAULT: Exact period days logic for unknown date_range values
                    prev_end_date = start_date_dt - timedelta(days=1)
                    prev_start_date = prev_end_date - timedelta(days=period_days - 1)
                    ext_end_date = end_date_dt + timedelta(days=1)
                
                return {
                    "start_date": start_date_dt.isoformat(),
                    "end_date": end_date_dt.isoformat(),
                    "previous_start_date": prev_start_date.isoformat(),
                    "previous_end_date": prev_end_date.isoformat(),
                    "extended_end_date": ext_end_date.isoformat(),
                    "date_range": date_range,
                    "period_days": period_days
                }
                
            except ValueError:
                return JSONResponse(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    content={"msg": "Invalid date format. Use YYYY-MM-DD."}
                )
        else:
            # Default to daily
            start_date_dt = today
            end_date_dt = today
            period_days = 1
            prev_end_date = start_date_dt - timedelta(days=1)
            prev_start_date = prev_end_date - timedelta(days=period_days - 1)
            ext_end_date = end_date_dt + timedelta(days=1)
            
            return {
                "start_date": start_date_dt.isoformat(),
                "end_date": end_date_dt.isoformat(),
                "previous_start_date": prev_start_date.isoformat(),
                "previous_end_date": prev_end_date.isoformat(),
                "extended_end_date": ext_end_date.isoformat(),
                "date_range": "day",
                "period_days": period_days
            }
            
    except Exception as e:
        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content={"msg": f"Internal server error: {str(e)}"}
        )




pip installs python-dateutil

from datetime import datetime, date, timedelta
from dateutil.relativedelta import relativedelta
from typing import Optional
from fastapi import Query, Header, Depends
from fastapi.responses import JSONResponse
from fastapi import status
from auth.jwt_handler import AuthJWT

@router.get('/get_team_active_idle_app_category')
async def get_team_app_activity(
    Authorize: AuthJWT = Depends(),
    authorization: str = Header(None),
    start_date: str = Query(...),
    end_date: str = Query(...),
    date_range: Optional[str] = Query("day")
):
    if not authorization or not authorization.startswith("Bearer"):
        return JSONResponse(
            status_code=status.HTTP_400_BAD_REQUEST,
            content={"msg": "Authorization Token Missing"}
        )
    
    try:
        Authorize.jwt_required()
        user_identity = Authorize.get_jwt_subject()
        claims = Authorize.get_raw_jwt()
        manager_id = claims.get("user_id")
        
        if not manager_id:
            return JSONResponse(
                status_code=status.HTTP_401_UNAUTHORIZED,
                content={'message': "Invalid Token Claims"}
            )
        
        today = datetime.today().date()
        
        if start_date and end_date:
            try:
                start_date_dt = datetime.strptime(start_date, "%Y-%m-%d").date()
                end_date_dt = datetime.strptime(end_date, "%Y-%m-%d").date()
                
                period_days = (end_date_dt - start_date_dt).days + 1
                
                # Handle different date range types
                if date_range.lower() == "day":
                    # Previous week's same day
                    prev_start_date = start_date_dt - timedelta(days=7)
                    prev_end_date = prev_start_date  # Same day for day range
                    ext_end_date = end_date_dt + timedelta(days=1)
                    
                elif date_range.lower() == "week":
                    # Previous week's same days (exact number of days)
                    prev_start_date = start_date_dt - timedelta(days=7)
                    prev_end_date = end_date_dt - timedelta(days=7)
                    ext_end_date = end_date_dt + timedelta(days=1)
                    
                elif date_range.lower() == "month":
                    # Check if selected dates are in current month
                    current_month = today.month
                    current_year = today.year
                    selected_month = start_date_dt.month
                    selected_year = start_date_dt.year
                    
                    if selected_month == current_month and selected_year == current_year:
                        # Current month: go back exactly 4 weeks (28 days)
                        prev_start_date = start_date_dt - timedelta(days=28)
                        prev_end_date = end_date_dt - timedelta(days=28)
                    else:
                        # Not current month: previous month's start and end
                        # Get first day of previous month for start_date
                        prev_start_date = (start_date_dt.replace(day=1) - relativedelta(months=1)).replace(day=1)
                        
                        # Get last day of previous month for end_date
                        prev_month_end = (end_date_dt.replace(day=1) - relativedelta(months=1))
                        prev_end_date = (prev_month_end + relativedelta(months=1, days=-1))
                    
                    ext_end_date = end_date_dt + timedelta(days=1)
                
                else:
                    # Default to day logic for unknown ranges
                    prev_start_date = start_date_dt - timedelta(days=7)
                    prev_end_date = prev_start_date
                    ext_end_date = end_date_dt + timedelta(days=1)
                
                # Return the calculated dates
                return {
                    "start_date": start_date_dt.isoformat(),
                    "end_date": end_date_dt.isoformat(),
                    "previous_start_date": prev_start_date.isoformat(),
                    "previous_end_date": prev_end_date.isoformat(),
                    "extended_end_date": ext_end_date.isoformat(),
                    "date_range": date_range,
                    "period_days": period_days
                }
                
            except ValueError:
                return JSONResponse(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    content={"msg": "Invalid date format. Use YYYY-MM-DD."}
                )
        else:
            # Default to daily when no dates provided
            start_date_dt = today
            end_date_dt = today
            prev_start_date = today - timedelta(days=7)
            prev_end_date = prev_start_date
            ext_end_date = today + timedelta(days=1)
            
            return {
                "start_date": start_date_dt.isoformat(),
                "end_date": end_date_dt.isoformat(),
                "previous_start_date": prev_start_date.isoformat(),
                "previous_end_date": prev_end_date.isoformat(),
                "extended_end_date": ext_end_date.isoformat(),
                "date_range": "day",
                "period_days": 1
            }
            
    except Exception as e:
        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content={"msg": f"Internal server error: {str(e)}"}
        )







Here’s a cleaner, structured draft you can use for your proposal email or document:


---

Subject: Proposal to Exclude Week-Off Data from Average Calculations in RPEM APIs

Background:
Currently, our system captures and stores agent activity data for all employees, regardless of whether the date falls on a working day or a week-off (e.g., Saturday, Sunday, or designated weekly off-days). This includes cases where an employee might log in briefly (e.g., 10 minutes or 1 hour) during their week-off.

When average calculations are performed — whether for a week, month, or custom date range — this week-off data is included in the calculation. As a result:

A small amount of activity on a week-off skews both individual and team averages.

The reported averages may not accurately reflect true working-day performance.


Proposed Change:
For all APIs that calculate averages in RPEM, we propose excluding week-off employee activity from the average computation. This means:

If a date is a week-off for a given employee, their data for that date will be ignored in average calculations.

Averages will be calculated only on valid working days for each employee.


Expected Benefits:

More accurate and meaningful average metrics for individuals and teams.

Avoids distortion of averages caused by minimal week-off activity.

Consistency across all APIs, regardless of the selected time period filter (week, month, or custom).


Scope:

Changes will be implemented in all RPEM APIs that involve average calculations.

The logic to exclude week-off data will be applied at the calculation stage.


Request:
We seek sign-off on this proposal so that development can proceed with updating all relevant APIs to exclude week-off data from average computations.


---

Do you want me to also add a visual example showing how averages change before vs. after this change? That would make the proposal even easier to approve.

